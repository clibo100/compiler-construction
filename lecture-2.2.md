
Where are we in the course? So far, we explained the basic ideas of compiler construction and the four main phases: lexing, parsing, type checking, code generation.

Lexers implement mathematical structures called determinstic finite automata (DFA). You have implemented some DFAs in Assignment 1 already. 

DFAs also are important in many other areas of computer science, for example, in Digital Logic Design and in Computer Architecture, see Chapter 3.4 of [Digital Design and Computer Architecture](https://www.elsevier.com/books/digital-design-and-computer-architecture/harris/978-0-12-394424-5).

The plan for the next lectures is to learn how to go from regular expressions to non-deterministic automata to deterministic automata. Here is a [good online article about history and implementations](https://swtch.com/~rsc/regexp/regexp1.html).

Let us get started learning the basics.

The topic of the lecture is Chapter 2.2 of [Introduction to Automata Theory, Languages, and Computation by Hopcroft, Motwani, Ullman]( https://mcdtu.files.wordpress.com/2017/03/introduction-to-automata-theory.pdf).

Chapter 1 contains a review of some mathematical foundations of automata theory.

Plan for the lecture is Chapter 2.2.

Read the box on page 52 carefully.

Do the following exercises: Exercise 2.2.4 ( possibly 2.2.5 and 2.2.6) and Exercise 2.2.10 (possibly 2.2.11). You don't need to do a formal prove by induction but think about an argument showing that your language is the correct one. **These exercises are relevant preparation for tests and final.** 






